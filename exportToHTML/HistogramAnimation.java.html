<html>
<head>
<title>HistogramAnimation.java</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #000080; font-weight: bold;}
.s1 { color: #000000;}
.s2 { color: #0000ff;}
.s3 { color: #808080; font-style: italic;}
.s4 { color: #008000; font-weight: bold;}
</style>
</head>
<body bgcolor="#ffffff">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#c0c0c0" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
HistogramAnimation.java</font>
</center></td></tr></table>
<pre><span class="s0">import </span>java.awt.Color;
<span class="s0">import </span>java.awt.Font;
<span class="s0">import </span>java.util.Arrays;
<span class="s0">import </span>java.util.Comparator;
<span class="s0">import </span>java.util.HashMap;
<span class="s0">import </span>java.util.Random;

<span class="s0">class </span>Canvas {
   <span class="s0">int </span>x = <span class="s2">512</span>, y = <span class="s2">512</span>;
   <span class="s0">double</span>[] xScale = { <span class="s2">0</span>, <span class="s2">1.0 </span>};  <span class="s3">// MIN, MAX</span>
   <span class="s0">double</span>[] yScale = { <span class="s2">0</span>, <span class="s2">1.0 </span>};  <span class="s3">// MIN, MAX</span>
   Color bgColor = Color.WHITE;
   Color color = Color.BLACK;
}

<span class="s0">class </span>Formats {
   <span class="s0">double</span>[] margins = { <span class="s2">0.15</span>, <span class="s2">0.15</span>, <span class="s2">0.15</span>, <span class="s2">0.15 </span>};  <span class="s3">// NORTH, SOUTH, WEST, EAST</span>
   <span class="s0">boolean </span>isBarFilled = <span class="s0">true</span>;
   Color barFillColor = <span class="s0">new </span>Color(<span class="s2">0x32d3eb</span>);
   <span class="s0">boolean </span>hasBarFrame = <span class="s0">true</span>;
   Color barFrameColor = <span class="s0">new </span>Color(<span class="s2">0x60acfc</span>);
   <span class="s0">boolean </span>hasBorder = <span class="s0">true</span>;
   Color borderColor = <span class="s0">new </span>Color(<span class="s2">0x606060</span>);
   Color rulerColor = <span class="s0">new </span>Color(<span class="s2">0x333333</span>);
   Color rulerMarkColor = <span class="s0">new </span>Color(<span class="s2">0xf7f7f7</span>);
   <span class="s0">boolean </span>hasRightRuler = <span class="s0">true</span>;
   Color keyColor = <span class="s0">new </span>Color(<span class="s2">0x333333</span>);
   <span class="s0">boolean </span>hasHeader = <span class="s0">true</span>;
   Color headerColor = <span class="s0">new </span>Color(<span class="s2">0x333333</span>);
   <span class="s0">boolean </span>hasFooter = <span class="s0">true</span>;
   Color footerColor = <span class="s0">new </span>Color(<span class="s2">0x333333</span>);
   Font rulerFont =  <span class="s0">new </span>Font( <span class="s4">&quot;consolas&quot;</span>, Font.PLAIN, <span class="s2">12 </span>);
   Font keyFont = <span class="s0">new </span>Font( <span class="s4">&quot;consolas&quot;</span>, Font.PLAIN, <span class="s2">12 </span>);
   Font headerFont = <span class="s0">new </span>Font( <span class="s4">&quot;calibri&quot;</span>, Font.PLAIN, <span class="s2">20 </span>);
   Font footerFont = <span class="s0">new </span>Font( <span class="s4">&quot;calibri&quot;</span>, Font.PLAIN, <span class="s2">20 </span>);
   String rulerNumberFormat = <span class="s0">null</span>;
   Font stepFont = <span class="s0">new </span>Font(<span class="s4">&quot;consolas&quot;</span>, Font.PLAIN, <span class="s2">42</span>);

    <span class="s0">int </span>visibleCount = <span class="s2">16</span>;
<span class="s3">//   int[][] colorList = {};</span>
}

<span class="s0">class </span>HistogramData {
   String header = <span class="s4">&quot;&quot;</span>;
   String footer = <span class="s4">&quot;&quot;</span>;
   <span class="s0">double </span>minValue = <span class="s2">0.0</span>;
   String[] steps = { };
   String[] labels = { };
   <span class="s0">double</span>[][] values = { };
   Item[][] items;
   <span class="s0">int </span>stepIndex = <span class="s2">0</span>;
   HashMap&lt;Integer, Color&gt; colorMap;
 }

<span class="s0">class </span>Item {
    <span class="s0">int </span>labelIndex;
    <span class="s0">double </span>value;
    <span class="s0">double </span>grade = <span class="s2">0</span>;
}

<span class="s0">class </span>ItemComparator <span class="s0">implements </span>Comparator&lt;Item&gt;{
    @Override
    <span class="s0">public int </span>compare(Item e1, Item e2) {
        <span class="s0">if</span>(e1.value &lt; e2.value) <span class="s0">return </span><span class="s2">1</span>;
        <span class="s0">if</span>(e1.value &gt; e2.value) <span class="s0">return </span>-<span class="s2">1</span>;
        <span class="s0">return </span><span class="s2">0</span>;
    }
}

<span class="s0">public class </span>HistogramAnimation {
   Canvas c;
   Formats f;
   HistogramData d;
   <span class="s0">double</span>[] xValue;  <span class="s3">// MIN, MAX</span>
   <span class="s0">double</span>[] yValue;  <span class="s3">// MIN, MAX</span>
   <span class="s0">double</span>[] xScale;  <span class="s3">// MIN, MAX</span>
   <span class="s0">double</span>[] yScale;  <span class="s3">// MIN, MAX</span>
   <span class="s0">int </span>rulerGrade;   
   <span class="s0">double </span>rulerStep;

   <span class="s0">public </span>HistogramAnimation(Canvas c, Formats f, HistogramData d) {
      <span class="s0">this</span>.c = c;
      <span class="s0">this</span>.f = f;
      <span class="s0">this</span>.d = d;
      xValue = <span class="s0">new double</span>[<span class="s2">2</span>];
      yValue = <span class="s0">new double</span>[<span class="s2">2</span>];
      xScale = <span class="s0">new double</span>[<span class="s2">2</span>];
      yScale = <span class="s0">new double</span>[<span class="s2">2</span>];

   }

   <span class="s0">private static </span>Color genRandColor() {
       Random random = <span class="s0">new </span>Random();

       <span class="s0">int </span>r = random.nextInt(<span class="s2">256</span>);
       <span class="s0">int </span>g = random.nextInt(<span class="s2">256</span>);
       <span class="s0">int </span>b = random.nextInt(<span class="s2">256</span>);
       <span class="s3">// some little trick to get fine color</span>
       // but can not get rid of duplicate colors
       <span class="s0">while </span>((r&gt;<span class="s2">200 </span>&amp;&amp; g&gt;<span class="s2">200 </span>&amp;&amp; b&gt;<span class="s2">200</span>) || (r&lt;<span class="s2">100 </span>&amp;&amp; g&lt;<span class="s2">100 </span>&amp;&amp; b&lt;<span class="s2">100</span>))
       {
           r = random.nextInt(<span class="s2">256</span>);
           g = random.nextInt(<span class="s2">256</span>);
           b = random.nextInt(<span class="s2">256</span>);
       }
       <span class="s0">return new </span>Color(r, g, b);
   }

   <span class="s0">private void </span>interpolate(<span class="s0">int </span>i) {
       <span class="s0">int </span>nLabel = d.labels.length;
       <span class="s0">for </span>(<span class="s0">int </span>j = <span class="s2">0</span>; j &lt; nLabel; j++) {
           Item item = d.items[(i) * INTERP_COUNT][j];
           Item[] nextItems = d.items[(i+<span class="s2">1</span>)* INTERP_COUNT];
           <span class="s3">// find the matching one TODO this algorithm should be improved (or improve data structure?) otherwise the complexity would explode</span>
           Item nextItem = <span class="s0">null</span>;
           <span class="s0">for </span>(<span class="s0">int </span>k = <span class="s2">0</span>; k &lt; nLabel; k++) {
                <span class="s0">if </span>(item.labelIndex == nextItems[k].labelIndex) {
                    nextItem = nextItems[k];
                    <span class="s0">break</span>;
                }
           }
           <span class="s0">double </span>vStep = (nextItem.value - item.value) / INTERP_COUNT;
           <span class="s0">double </span>gStep = (nextItem.grade - item.grade) / INTERP_COUNT;

           <span class="s0">for </span>(<span class="s0">int </span>m = <span class="s2">1</span>; m &lt; INTERP_COUNT; m++) {
               d.items[(i) * INTERP_COUNT + m][j] = <span class="s0">new </span>Item();
               Item targetItem = d.items[(i) * INTERP_COUNT + m][j];
               targetItem.labelIndex = item.labelIndex;
               targetItem.value = item.value + vStep * m;
               targetItem.grade = item.grade + gStep * m;

           }
       }
   }

   <span class="s0">private void </span>preCompute() {
       <span class="s0">int </span>nStep = d.steps.length;
       <span class="s0">int </span>nLabel = d.labels.length;
       d.items = <span class="s0">new </span>Item[(nStep - <span class="s2">1</span>)* INTERP_COUNT + <span class="s2">1</span>][nLabel];
       <span class="s0">for </span>(<span class="s0">int </span>i = <span class="s2">0</span>; i &lt; nStep; i++) { <span class="s3">// for every country</span>
           <span class="s0">for </span>(<span class="s0">int </span>j = <span class="s2">0</span>; j &lt; nLabel; j++) { <span class="s3">// for every year</span>
                Item e = <span class="s0">new </span>Item();
                e.labelIndex = j;
                e.value = d.values[j][i];
                d.items[i* INTERP_COUNT][j] = e; <span class="s3">// the index is inverse</span>
           }
           Arrays.sort(d.items[i*INTERP_COUNT], <span class="s0">new </span>ItemComparator());
           <span class="s0">for </span>(<span class="s0">int </span>k = <span class="s2">0</span>; k &lt; d.items[i*INTERP_COUNT].length; k++) {
              d.items[i* INTERP_COUNT][k].grade = k;
           }
           <span class="s0">if </span>(i&gt;<span class="s2">0</span>) {
                interpolate(i - <span class="s2">1</span>);
           }
       }
       Item[] tempItems = d.items[(nStep - <span class="s2">1</span>) *INTERP_COUNT];
       d.colorMap = <span class="s0">new </span>HashMap&lt;&gt;();
       <span class="s0">for </span>(<span class="s0">int </span>i = <span class="s2">0</span>; i &lt; nLabel; i++) {
           d.colorMap.put(tempItems[i].labelIndex, genRandColor());
       }
   }

   <span class="s0">private void </span>setHistogramParameters () {
      Item[] a = d.items[d.stepIndex];
      yValue[MIN] = <span class="s2">0</span>;
      yValue[MAX] = f.visibleCount;
      <span class="s0">double </span>max = a[<span class="s2">0</span>].value;
      xValue[MIN] = d.minValue;
      <span class="s0">double </span>span = max - xValue[MIN];
      <span class="s0">double </span>factor = <span class="s2">1.0</span>;
      <span class="s0">if </span>(span &gt;= <span class="s2">1</span>)
         <span class="s0">while </span>(span &gt;= <span class="s2">10</span>) { span /= <span class="s2">10</span>; factor *= <span class="s2">10</span>; } 
      <span class="s0">else</span>
         while (span &lt; <span class="s2">1</span>)   { span *= <span class="s2">10</span>; factor /= <span class="s2">10</span>; }
      <span class="s0">int </span>nSpan = (<span class="s0">int</span>)Math.ceil(span);
      xValue[MAX] = max;

      <span class="s0">switch </span>(nSpan) {
         <span class="s0">case </span><span class="s2">1 </span>:  rulerGrade = <span class="s2">5</span>; rulerStep = factor/<span class="s2">5</span>; <span class="s0">break</span>;
         <span class="s0">case </span><span class="s2">2 </span>:
         <span class="s0">case </span><span class="s2">3 </span>:  rulerGrade = nSpan*<span class="s2">2</span>; rulerStep = factor/<span class="s2">2</span>; <span class="s0">break</span>;
         <span class="s0">default </span>: rulerGrade = nSpan; rulerStep = factor; <span class="s0">break</span>;
      }
   }
   <span class="s0">public void </span>animate() {
       preCompute();
       StdDraw.enableDoubleBuffering();
       setCanvas();
       <span class="s0">int </span>n = d.items.length;
       <span class="s0">for </span>(<span class="s0">int </span>i = <span class="s2">0</span>; i &lt; n; i++) {
           StdDraw.clear();
           d.stepIndex = i;
           setHistogramParameters();
           drawBase();
           StdDraw.show();
           StdDraw.pause(<span class="s2">50</span>);
       }
   }

   <span class="s0">public void </span>drawBase() {
      plotRuler();
      plotBars();
      plotStep();
      <span class="s0">if </span>(f.hasHeader) plotHeader();
   }

   <span class="s0">private void </span>setCanvas () {
      StdDraw.setCanvasSize( c.x, c.y );
      setOriginalScale();
      StdDraw.clear( c.bgColor);
      StdDraw.setPenColor( c.color);
   }

   <span class="s0">private void </span>setHistogramScale (<span class="s0">int </span>nBars) {
      <span class="s0">double </span>ySpacing = (nBars + <span class="s2">1</span>) / (<span class="s2">1 </span>- f.margins[NORTH] - f.margins[SOUTH]);
      yScale[MIN] = yValue[MIN] - f.margins[SOUTH] * ySpacing;
      yScale[MAX] = yValue[MAX] + f.margins[NORTH] * ySpacing;
      StdDraw.setYscale( yScale[MIN], yScale[MAX]);

      <span class="s0">double </span>span = xValue[MAX] - xValue[MIN];
      <span class="s0">double </span>xSpacing = span / (<span class="s2">1 </span>- f.margins[WEST] - f.margins[EAST]);
      xScale[MIN] = xValue[MIN] - f.margins[WEST] * xSpacing;
      xScale[MAX] = xValue[MAX] + f.margins[EAST] * xSpacing; <span class="s3">// TODO always scale to the maximum value</span>
      StdDraw.setXscale( xScale[MIN], xScale[MAX]);
   };

   <span class="s0">private void </span>setOriginalScale() {
      StdDraw.setXscale( c.xScale[MIN], c.xScale[MAX]);
      StdDraw.setYscale( c.yScale[MIN], c.yScale[MAX]);
   }

   <span class="s0">private void </span>plotBars () {
      Item[] a = d.items[d.stepIndex];
      <span class="s0">int </span>n = f.visibleCount;
      setHistogramScale( n );

       <span class="s0">double </span>span = xValue[MAX] - xValue[MIN];
       <span class="s0">double </span>xSpacing = span / (<span class="s2">1 </span>- f.margins[WEST] - f.margins[EAST]);

      <span class="s0">if </span>(f.isBarFilled) {

         <span class="s0">for </span>(<span class="s0">int </span>i = <span class="s2">0</span>; i &lt; n; i++) {
             <span class="s0">if </span>(n - a[i].grade &lt; -<span class="s2">1</span>) <span class="s0">continue</span>;
             StdDraw.setPenColor( d.colorMap.get(a[i].labelIndex));
             StdDraw.filledRectangle(a[i].value/<span class="s2">2</span>, n -a[i].grade, a[i].value/<span class="s2">2</span>, <span class="s2">0.25</span>);
                             <span class="s3">// (x, y, halfWidth, halfHeight)</span>
             StdDraw.textRight(-<span class="s2">0.005</span>*xSpacing, n-a[i].grade, d.labels[a[i].labelIndex]);
             StdDraw.textLeft(a[i].value + <span class="s2">0.005</span>*xSpacing, n-a[i].grade,  String.valueOf((<span class="s0">int</span>)(a[i].value)));
         }
      }
   }

   <span class="s0">private void </span>plotStep() {
       StdDraw.setFont( f.stepFont );
       StdDraw.setPenColor(<span class="s0">new </span>Color(<span class="s2">100</span>, <span class="s2">100</span>, <span class="s2">100</span>));
       String step = d.steps[d.stepIndex / INTERP_COUNT];

       StdDraw.textRight(xValue[MAX], yValue[MIN] + <span class="s2">1.5</span>, step);
   }

   <span class="s0">private void </span>plotRuler() {
<span class="s3">//      Font font = new Font( &quot;consolas&quot;, Font.PLAIN, 12 ); // TO BE Customized</span>
      StdDraw.setFont( f.rulerFont );
      StdDraw.setPenColor( f.rulerColor );
      <span class="s0">final double </span>y0 = yValue[MIN], y1 = yValue[MAX];
      String[] mark = <span class="s0">new </span>String[rulerGrade+<span class="s2">1</span>];
      <span class="s0">for </span>(<span class="s0">int </span>i = <span class="s2">0</span>; i &lt;= rulerGrade; i++) {
         <span class="s0">double </span>x = xValue[MIN] + i * rulerStep;
         mark[i] = numberForRuler( x );
         <span class="s0">if </span>(x &lt; xValue[MAX])
             StdDraw.line( x, y0, x, y1 );
      }
      <span class="s0">int </span>len = maxMarkLength( mark );      
      <span class="s0">final double </span>ys = yScale[MIN] + <span class="s2">0.7 </span>* (yValue[MIN] - yScale[MIN]);
      <span class="s0">for </span>(<span class="s0">int </span>i = <span class="s2">0</span>; i &lt;= rulerGrade; i++) {
         <span class="s0">double </span>x = xValue[MIN] + i * rulerStep;
         <span class="s0">if </span>(x &lt; xValue[MAX])
            StdDraw.text( x, ys, String.format( <span class="s4">&quot;%&quot; </span>+ len + <span class="s4">&quot;s&quot;</span>, mark[i] ));
      }
   }
   
   <span class="s0">private </span>String numberForRuler (<span class="s0">double </span>x) {   <span class="s3">// TO BE Customized</span>
      <span class="s0">if </span>(f.rulerNumberFormat != <span class="s0">null</span>) <span class="s0">return </span>String.format(f.rulerNumberFormat, x); <span class="s3">// only accept formats for double type!</span>
      <span class="s0">if </span>(yValue[MAX] &gt;= <span class="s2">5 </span>&amp;&amp; rulerStep &gt; <span class="s2">1</span>) <span class="s0">return </span><span class="s4">&quot;&quot; </span>+ (<span class="s0">int</span>)x;
      <span class="s0">if </span>(rulerStep &gt; <span class="s2">0.1</span>) <span class="s0">return </span>String.format( <span class="s4">&quot;%.1f&quot;</span>, x ); 
      <span class="s0">if </span>(rulerStep &gt; <span class="s2">0.01</span>) <span class="s0">return </span>String.format( <span class="s4">&quot;%.2f&quot;</span>, x ); 
      <span class="s0">if </span>(rulerStep &gt; <span class="s2">0.001</span>) <span class="s0">return </span>String.format( <span class="s4">&quot;%.3f&quot;</span>, x ); 
      <span class="s0">if </span>(rulerStep &gt; <span class="s2">0.0001</span>) <span class="s0">return </span>String.format( <span class="s4">&quot;%.4f&quot;</span>, x ); 
      <span class="s0">if </span>(rulerStep &gt; <span class="s2">0.00001</span>) <span class="s0">return </span>String.format( <span class="s4">&quot;%.5f&quot;</span>, x ); 
      <span class="s0">return </span>String.format( <span class="s4">&quot;%g&quot;</span>, x );
   }      

   <span class="s0">private int </span>maxMarkLength (String[] sa) {
      <span class="s0">int </span>n = sa[<span class="s2">0</span>].length();
      <span class="s0">for </span>(String s : sa)
         <span class="s0">if </span>(n &lt; s.length()) n = s.length(); 
      <span class="s0">return </span>n;
   }

   <span class="s0">private void </span>plotBorder() {
      <span class="s0">double </span>x = <span class="s2">.5 </span>* (xValue[MIN] + xValue[MAX]);
      <span class="s0">double </span>y = <span class="s2">.5 </span>* (yValue[MIN] + yValue[MAX]);
      <span class="s0">double </span>halfWidth  = <span class="s2">.5 </span>* (xValue[MAX] - xValue[MIN]);
      <span class="s0">double </span>halfHeight = <span class="s2">.5 </span>* (yValue[MAX] - yValue[MIN]);
      StdDraw.setPenColor( f.borderColor );
      StdDraw.rectangle( x, y, halfWidth, halfHeight);
   } 

   <span class="s0">private void </span>plotRightRuler() {} <span class="s3">//TODO</span>
   
   <span class="s0">private void </span>plotHeader() {
<span class="s3">//      Font font = new Font( &quot;calibri&quot;, Font.PLAIN, 20 ); // TO BE Customized</span>
      StdDraw.setFont( f.headerFont );
      <span class="s0">double </span>x = <span class="s2">.5 </span>* (xScale[MIN] + xScale[MAX]);
      <span class="s0">double </span>y = <span class="s2">.5 </span>* (yValue[MAX] + yScale[MAX]);
      StdDraw.setPenColor( f.headerColor );
      StdDraw.text( x, y, d.header );
   } 

   
   <span class="s0">private final static int </span>NORTH = <span class="s2">0</span>;
   <span class="s0">private final static int </span>SOUTH = <span class="s2">1</span>;
   <span class="s0">private final static int </span>WEST  = <span class="s2">2</span>;
   <span class="s0">private final static int </span>EAST  = <span class="s2">3</span>;
   <span class="s0">private final static int </span>MIN  = <span class="s2">0</span>;
   <span class="s0">private final static int </span>MAX  = <span class="s2">1</span>;
   <span class="s0">private final static int </span>INTERP_COUNT = <span class="s2">30</span>;
}
</pre>
</body>
</html>